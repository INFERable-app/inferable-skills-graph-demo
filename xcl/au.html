<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Conflict Resolution Practice — The Marketing Budget Battle</title>
<script src="https://jgoodell2.github.io/itemGen/webComponents/percentGauge.js" type="module"></script>
<style>
  :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;sans-serif;color:#111}
  body{margin:0;padding:24px;max-width:900px;margin-left:auto;margin-right:auto;background:#f7f8fb}
  header{background:#2b6cb0;color:white;padding:18px;border-radius:10px}
  h1{margin:0;font-size:20px}
  .card{background:white;padding:18px;border-radius:10px;margin-top:16px;box-shadow:0 6px 18px rgba(11,22,50,0.06)}
  .question{margin-top:10px}
  .choices{margin-top:12px}
  label.choice{display:block;padding:10px;border-radius:8px;border:1px solid #e6eef8;margin-bottom:8px;cursor:pointer}
  label.choice input{margin-right:10px}
  .controls{display:flex;gap:8px;align-items:center;margin-top:14px}
  button{background:#2b6cb0;color:white;border:none;padding:10px 14px;border-radius:8px;cursor:pointer}
  button[disabled]{opacity:0.5;cursor:not-allowed}
  .feedback{margin-top:12px;padding:12px;border-radius:8px;background:#f1f6ff;border:1px solid #d6e8ff}
  footer{margin-top:18px;font-size:13px;color:#555}
  .config{display:flex;gap:8px;align-items:center;margin-top:12px;flex-wrap:wrap}
  .config input{padding:8px;border-radius:6px;border:1px solid #cfd8e3}
  .log{font-family:monospace;background:#0b1220;color:#d8f1ff;padding:12px;border-radius:8px;margin-top:12px;overflow:auto;max-height:240px}
  .stage{font-weight:600;color:#2b6cb0}
</style>
</head>
<body>
<header>
  <h1>Conflict Resolution Practice — The Marketing Budget Battle</h1>
</header>

<div class="card" id="intro">
  <p>You are the manager for Sarah and Mark, two experienced project managers who disagree on the Q3 marketing budget. Use this interactive exercise to practice diagnosing conflict, facilitating dialogue, and formalizing a lasting resolution.</p>
  <p class="stage">Status: <span id="status">Not started</span></p>

  <div style="margin-top:12px">
    <button id="startBtn">Start Exercise</button>
  </div>
</div>

<div id="au" style="display:none">
  <div class="card" id="stepCard">
    <h2 id="stepTitle">Step</h2>
    <div id="scenarioText"></div>
    <form id="choicesForm" class="question" onsubmit="return false;">
      <div class="choices" id="choices"></div>
      <div class="controls">
        <button id="submitAnswer" disabled>Submit Answer</button>
        <button id="nextBtn" style="display:none">Next</button>
        <div style="margin-left:auto"><small id="progress"></small></div>
      </div>
    </form>
    <div id="feedbackArea"></div>
  </div>

  <div class="card" style="visibility: hidden;">
    <h3>xAPI Statement Log (for debugging)</h3>
    <div class="log" id="logArea"></div>
    <footer>AU generates xAPI statements (initialized, answered, completed). You can configure an LRS to receive them.</footer>
  </div>
</div>

<script src="../js/cryptojs_v3.1.2.js"></script>
<script src="../js/xAPIWrapper.js"></script>
<script src="../js/jimsxapiwrapper.js"></script>
<script>
/*
  Simple xAPI statement sender. If LRS configured (endpoint + basic auth), sends statement via fetch.
  Otherwise, stores in localStorage and prints to on-page log and console.
*/
const logArea = document.getElementById('logArea');
function log(msg){
  const time = (new Date()).toISOString();
  logArea.textContent = time + " — " + msg + "\\n" + logArea.textContent;
  console.log(time + " — " + msg);
}

function getConfig(){
  const urlParams = new URLSearchParams(window.location.search);
  return {
    endpoint: 'http://146.190.70.120:8080/xapi/' || urlParams.get('endpoint') || '',
    auth: "8d17bca86ccfd3bf25897a70f01846dfbe621f2ff9ddb28c58c60a467aeaf6b1:37b661e683780adb9a76262b310dee32cb6413553da613a7a13621675877bb59" ||urlParams.get('auth') || '',
    registration: urlParams.get('registration') || '',
    grouping: urlParams.get('grouping') || '',
    activity_id: urlParams.get('activity_id') || 'urn:uuid:marketing-budget-battle-au'
  };
}

// Minimal xAPI statement builder and sender
async function sendStatement(stmt){
  const cfg = getConfig();
  const body = JSON.stringify(stmt);
  console.log('===== SEND STATEMENT =====');
  console.log('Statement Verb:', stmt.verb?.display?.['en-US'] || 'unknown');
  console.log('Full config:', {endpoint: cfg.endpoint, auth: cfg.auth ? '[REDACTED]' : 'none', registration: cfg.registration, grouping: cfg.grouping, activity_id: cfg.activity_id});
  console.log('Statement payload:', stmt);

  // Prefer using ADL.XAPIWrapper when available (aligns behavior with skill-practice-with-gauge)
  if (window.ADL && ADL.XAPIWrapper && typeof ADL.XAPIWrapper.changeConfig === 'function') {
    try {
      const authVal = cfg.auth && !cfg.auth.startsWith('Basic ') ? ('Basic ' + (typeof toBase64 === 'function' ? toBase64(cfg.auth) : btoa(cfg.auth))) : (cfg.auth || '');
      const xapiConf = { endpoint: cfg.endpoint, auth: authVal };
      console.log('Using ADL.XAPIWrapper with config:', xapiConf);
      ADL.XAPIWrapper.changeConfig(xapiConf);
      try {
        const wrapperResult = ADL.XAPIWrapper.sendStatement(stmt);
        log('Statement sent to LRS via ADL.XAPIWrapper: ' + (stmt.verb && stmt.verb.display ? stmt.verb.display['en-US'] : 'unknown'));
        console.log('ADL.XAPIWrapper result:', wrapperResult);
      } catch (werr) {
        console.warn('ADL.XAPIWrapper.sendStatement failed, falling back to fetch. Error:', werr);
        // fall through to fetch fallback below
        throw werr;
      }
      return;
    } catch (err) {
      console.warn('ADL wrapper flow failed, will attempt manual fetch fallback:', err);
    }
  }

  // Manual fetch fallback (kept for environments without ADL.XAPIWrapper)
  if(cfg.endpoint){
    try{
      console.log('xAPI send - endpoint:', cfg.endpoint,
                  'auth:', cfg.auth ? '[REDACTED]' : 'none',
                  'registration:', cfg.registration,
                  'grouping:', cfg.grouping,
                  'activity_id:', cfg.activity_id);
      log('Sending statement to LRS endpoint: ' + cfg.endpoint + ' auth=' + (cfg.auth ? '[REDACTED]' : '') + ' registration=' + cfg.registration + ' grouping=' + cfg.grouping + ' activity_id=' + cfg.activity_id);

      const headers = {"Content-Type":"application/json", "Accept": "application/json", "X-Experience-API-Version": "1.0.3"};
      if(cfg.auth){
        if(!cfg.auth.startsWith('Basic ')){
          headers['Authorization'] = 'Basic ' + btoa(cfg.auth);
        } else {
          headers['Authorization'] = cfg.auth;
        }
      }
      const res = await fetch(cfg.endpoint + 'statements', {method: 'POST', headers, body, mode:'cors'});
      if(!res.ok){
        const text = await res.text().catch(() => null);
        log('Failed to send statement to LRS: HTTP ' + res.status + (text ? (' — ' + text) : '') + ' — stored locally.');
        console.error('LRS response body:', text);
        storeStatementLocally(stmt);
      } else {
        const text = await res.text().catch(() => null);
        log('Statement sent to LRS: ' + (stmt.verb && stmt.verb.display ? stmt.verb.display['en-US'] : 'unknown'));
        console.log('✓ Statement successfully sent to LRS; response:', text);
      }
    }catch(err){
      log('Error sending to LRS: ' + err + ' — stored locally.');
      console.error('xAPI send error', err);
      storeStatementLocally(stmt);
    }
  } else {
    console.log('No LRS endpoint configured, storing locally');
    storeStatementLocally(stmt);
  }
  console.log('=======================');
}

function storeStatementLocally(stmt){
  const arr = JSON.parse(localStorage.getItem('cmi5_local_statements') || '[]');
  arr.unshift(stmt);
  localStorage.setItem('cmi5_local_statements', JSON.stringify(arr));
  log('Statement stored locally: ' + (stmt.verb && stmt.verb.display ? stmt.verb.display['en-US'] : 'unknown'));
}

// Hard-coded competency and activity IDs for AU
const COMPETENCY_ID = 'urn:uuid:marketing-budget-battle-au_competency';
const ACTIVITY_ID = 'urn:uuid:marketing-budget-battle-au_activity';

// Helper to extract BKT parameters consistently for both statements and predictions
function getBKTParams() {
  const cfg = getConfig();
  ensureActor();

  // Derive user_id from ACTOR
  let userId = null;
  if (typeof ACTOR === 'string') {
    userId = ACTOR;
  } else if (ACTOR && ACTOR.mbox) {
    userId = ACTOR.mbox;
  } else if (ACTOR && ACTOR.openid) {
    userId = ACTOR.openid;
  } else if (ACTOR && ACTOR.account && ACTOR.account.homePage && ACTOR.account.name) {
    userId = `${ACTOR.account.homePage}/users/${ACTOR.account.name}`;
  } else if (ACTOR && ACTOR.name) {
    userId = ACTOR.name;
  } else {
    console.error('getBKTParams: unable to determine user identifier from ACTOR', ACTOR);
    return null;
  }

  // Extract auth_id and auth_secret from credentials
  let credentials = cfg.auth || '';
  if (credentials.startsWith('Basic ')) {
    try {
      const decoded = atob(credentials.slice(6));
      credentials = decoded;
    } catch (e) {
      console.warn('getBKTParams: failed to base64-decode Basic auth; using raw credentials', e);
    }
  }
  const [authId = '', authSecret = ''] = (credentials || '').split(':');

  return {
    competency_id: COMPETENCY_ID,
    user_id: userId,
    lrs_url: cfg.endpoint,
    auth_id: authId,
    auth_secret: authSecret
  };
}

// send_statement function matching skill-practice-with-gauge.html pattern
function send_statement(item, competency, response, success) {
  const actor = ensureActor();

  const verb = {
    "id": "http://adlnet.gov/expapi/verbs/answered",
    "display": { "en-US": "answered" }
  };

  const object = {
    "id": ACTIVITY_ID,
    "objectType": "Activity",
    "definition": {
      "name": { "en-US": "Conflict Resolution Practice — The Marketing Budget Battle" },
      "description": { "en-US": "Practice item for conflict resolution" },
      "type": "http://adlnet.gov/expapi/activities/question"
    }
  };

  const result = {
    "response": response,
    "success": success,
    "score": { "scaled": success ? 1.0 : 0.0 }
  };

  const context = {
    "contextActivities": {
      "category": [{
        "id": competency || COMPETENCY_ID,
        "objectType": "Activity",
        "definition": {
          "name": { "en-US": "Conflict Resolution Competency" },
          "type": "http://adlnet.gov/expapi/activities/competency"
        }
      }]
    }
  };

  const statement = {
    "actor": actor,
    "verb": verb,
    "object": object,
    "result": result,
    "context": context,
    "timestamp": new Date().toISOString()
  };

  try {
    const result = ADL.XAPIWrapper.sendStatement(statement);
    console.log('Statement sent via ADL.XAPIWrapper:', result);
  } catch (error) {
    console.error('Error sending statement:', error);
    // Fallback to sendStatement function defined above
    sendStatement(statement);
  }
}

async function getPrediction() {
  // Use the same BKT parameters as send_statement
  const params = getBKTParams();
  if (!params) {
    console.error('getPrediction: failed to get BKT parameters');
    return null;
  }

  console.log('getPrediction: using params:', { 
    competency_id: params.competency_id, 
    user_id: params.user_id, 
    lrs_url: params.lrs_url, 
    auth_id: params.auth_id ? '[REDACTED]' : '', 
    auth_secret: params.auth_secret ? '[REDACTED]' : '' 
  });

  const CONFIG = {
    bkt: {
      endpoint: 'https://bkt.inferable.rest',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      }
    }
  };

  const url = `${CONFIG.bkt.endpoint}` + '?' + new URLSearchParams(params).toString();
  console.log('BKT API GET fallback URL:', url);

  // Prefer POST flow: attempt to POST JSON to the BKT root endpoint first
  try {
    const postBody = {
      user_id: params.user_id,
      competency_id: params.competency_id,
      lrs_url: params.lrs_url,
      auth_id: params.auth_id,
      auth_secret: params.auth_secret
    };

    const postUrl = CONFIG.bkt.endpoint.replace(/\/$/, '') + '/';
    console.log('Attempting POST to BKT root:', postUrl, postBody);

    try {
      const postResp = await fetch(postUrl, {
        method: 'POST',
        headers: Object.assign({'Content-Type': 'application/json', 'Accept': 'application/json'}, CONFIG.bkt.headers || {}),
        body: JSON.stringify(postBody),
        cache: 'no-store'
      });

      console.log('BKT POST status:', postResp.status, postResp.statusText);

      if (postResp.ok) {
        const json = await postResp.json().catch(err => { console.error('Failed to parse BKT POST JSON', err); return null; });
        console.log('BKT POST JSON:', json);
        if (json && (json.prediction !== undefined)) updateCompletionGauge(json.prediction);
        return json;
      } else {
        console.warn('BKT POST not OK, falling back. Status:', postResp.status);
        // fall through to token/GET fallback
      }
    } catch (postErr) {
      console.warn('BKT POST error, will attempt fallback flows:', postErr);
      // fall through to token/GET fallback
    }

    // If POST to root did not succeed, fall back to token exchange / predict or legacy GET
    let token = null;
    if (params.auth_id && params.auth_secret) {
      try {
        const tokenUrl = CONFIG.bkt.endpoint.replace(/\/$/, '') + '/token';
        console.log('Requesting token from', tokenUrl);
        const tokenResp = await fetch(tokenUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Basic ' + btoa(params.auth_id + ':' + params.auth_secret)
          },
          body: JSON.stringify({ grant_type: 'client_credentials' }),
          cache: 'no-store'
        });
        if (tokenResp.ok) {
          const tokJson = await tokenResp.json().catch(() => null);
          token = tokJson && (tokJson.access_token || tokJson.token);
          console.log('Received token:', token ? '[REDACTED]' : token);
        } else {
          console.warn('Token exchange failed', tokenResp.status, tokenResp.statusText);
        }
      } catch (te) {
        console.warn('Token exchange error', te);
      }
    }

    if (token) {
      // POST a prediction request with the token to /predict
      const predictUrl = CONFIG.bkt.endpoint.replace(/\/$/, '') + '/predict';
      const predictBody = { user_id: params.user_id, lrs_url: params.lrs_url, activity_id: ACTIVITY_ID, competency_id: params.competency_id };
      console.log('POSTing prediction to', predictUrl, predictBody);
      const predResp = await fetch(predictUrl, {
        method: 'POST',
        headers: Object.assign({'Content-Type': 'application/json', 'Authorization': 'Bearer ' + token}, CONFIG.bkt.headers || {}),
        body: JSON.stringify(predictBody),
        cache: 'no-store'
      });
      if (!predResp.ok) {
        const text = await predResp.text().catch(() => null);
        console.error('Prediction POST failed:', predResp.status, predResp.statusText, text);
        // Fallback to legacy GET below
      } else {
        const json = await predResp.json().catch(err => { console.error('Failed to parse prediction JSON', err); return null; });
        console.log('Prediction POST JSON:', json);
        if (json && (json.prediction !== undefined)) {
          updateCompletionGauge(json.prediction);
        }
        return json;
      }
    }

    // Fallback: legacy GET request with credentials in query string
    const resp = await fetch(url, {
      headers: CONFIG.bkt.headers,
      cache: 'no-store'
    });
    console.log('BKT API Response status:', resp.status, resp.statusText);

    if (!resp.ok) {
      const text = await resp.text().catch(() => null);
      console.error('BKT request failed:', resp.status, resp.statusText, text);
      return null;
    }

    const json = await resp.json().catch(err => {
      console.error('Failed to parse BKT JSON response', err);
      return null;
    });
    console.log('BKT API Response JSON:', json);
    if (json && (json.prediction !== undefined)) updateCompletionGauge(json.prediction);
    return json;
  } catch (err) {
    console.error('getPrediction fetch error', err);
    return null;
  }
}

// Update full gauge in completion screen
function updateCompletionGauge(pred) {
  const pct = Math.max(0, Math.min(1, Number(pred || 0)));
  const gauge = document.getElementById('completionGauge');
  if (gauge) {
    gauge.setAttribute('gauge-value-decimal', pct.toString());
  }
}

// Utility: create basic actor for demo. In cmi5 this would typically come from LMS.
// We'll allow the user to enter an actor name by prompt for demo purposes.
let ACTOR = null;
function ensureActor(){
  if(ACTOR) return ACTOR;
  const urlParams = new URLSearchParams(window.location.search);
  const actorParam = urlParams.get('actor');
  if(actorParam){
    try {
      ACTOR = JSON.parse(decodeURIComponent(actorParam));
    } catch(e) {
      console.error('Failed to parse actor from URL', e);
    }
  }
  if(!ACTOR) {
    ACTOR = { "objectType":"Agent", "name":"Default Learner", "openid":"https://example.com/users/user-v1:1abcb33beeb811dca15f0ac3e47b887b" };
  }
  return ACTOR;
}

// Statement helpers
function makeStatement(verbId, verbDisplay, objectId, objectDef){
  const config = getConfig();
  const statement = {
    actor: ensureActor(),
    verb: { id: verbId, display: {"en-US": verbDisplay} },
    object: {
      objectType: "Activity",
      id: objectId.startsWith('urn:uuid:marketing-budget-battle:') ? objectId : config.activity_id,
      definition: Object.assign({
        name: {"en-US": "Conflict Resolution Practice — The Marketing Budget Battle"},
        description: {"en-US": "Scenario-based practice to diagnose, mediate, and follow up on a budget conflict between two managers."},
        type: "http://adlnet.gov/expapi/activities/assessment"
      }, objectDef || {})
    },
    context: {},
    timestamp: (new Date()).toISOString()
  };

  // Only include registration if it's a valid non-empty value (must be a UUID)
  if (config.registration && config.registration.trim() !== '') {
    statement.context.registration = config.registration;
  }

  // Add grouping if provided
  if (config.grouping && config.grouping !== '|') {
    statement.context.contextActivities = {
      grouping: [{ id: config.grouping }]
    };
  }

  // Ensure context.contextActivities exists and include the competency as a category
  const competencyId = 'urn:uuid:marketing-budget-battle-au_competency';
  statement.context.contextActivities = statement.context.contextActivities || {};
  // Add category entry for competency
  statement.context.contextActivities.category = statement.context.contextActivities.category || [];
  // Avoid duplicating the competency id if already present
  if (!statement.context.contextActivities.category.some(c => c && c.id === competencyId)) {
    statement.context.contextActivities.category.unshift({
      id: competencyId,
      objectType: 'Activity',
      definition: {
        name: { 'en-US': 'Conflict Resolution Competency' },
        type: 'http://adlnet.gov/expapi/activities/competency'
      }
    });
  }

  // Preserve grouping if provided in config
  if (config.grouping && config.grouping !== '|') {
    statement.context.contextActivities.grouping = statement.context.contextActivities.grouping || [];
    if (!statement.context.contextActivities.grouping.some(g => g && g.id === config.grouping)) {
      statement.context.contextActivities.grouping.unshift({ id: config.grouping });
    }
  }

  return statement;
}

// Flow definitions: steps with question, choices, feedback
const steps = [
  {
    id: "step1",
    title: "Step 1: Diagnose the Conflict",
    scenario: `Your first interaction is a separate meeting with Mark and Sarah to understand the situation. Your goal is to gather information and identify the core issue. Which initial approach best helps you diagnose the conflict effectively?`,
    choices: [
      { id: "A", text: "Tell them both that they need to compromise and find a solution immediately to prevent further delays.", correct:false,
        feedback: "Incorrect. Telling them to compromise immediately skips the crucial diagnostic phase. You need to understand their perspectives and underlying needs before pushing for a solution."},
      { id: "B", text: `Ask them, "What are you hoping to achieve with your proposed budget allocation, and what do you value in this project?"`, correct:true,
        feedback: "Correct. This approach uses open-ended questions to uncover their motivations and values, not just their positions."},
      { id: "C", text: "Focus on the facts: \"Mark, show me the data supporting your new platform; Sarah, show me the historical returns on your channels.\"", correct:false,
        feedback: "Incorrect. While data is important, focusing solely on facts might escalate the conflict by making it a 'data fight' and ignores the emotional or value-based aspects."},
      { id: "D", text: "Ask Mark why he's being so reckless and Sarah why she's being so resistant to change.", correct:false,
        feedback: "Incorrect. This option uses blaming language and takes sides, which destroys trust and impartiality."}
    ]
  },
  {
    id: "step2",
    title: "Step 2: Mediate and Facilitate Dialogue",
    scenario: `After understanding both perspectives (Mark wants growth, Sarah wants stability), you bring them together for a joint meeting in a neutral space. Your role is now a facilitator, not a judge. Which action should you take during this mediation meeting?`,
    choices: [
      { id: "A", text: "Present a solution you've devised based on the information gathered: a 50/50 split of the budget.", correct:false,
        feedback: "Incorrect. Imposing a solution removes their ownership of the outcome."},
      { id: "B", text: "Allow each person to present their case uninterrupted, and have them speak directly to each other, not you.", correct:true,
        feedback: "Correct. This empowers both individuals to communicate clearly and practice active listening."},
      { id: "C", text: "Take an active role in the debate, pointing out flaws in each of their arguments and steering them toward your preferred solution.", correct:false,
        feedback: "Incorrect. As the manager and mediator, you must remain unbiased."},
      { id: "D", text: "Focus the entire conversation on past performance issues and any personal friction you observed during your 1:1s.", correct:false,
        feedback: "Incorrect. This is a distraction from the current issue."}
    ]
  },
  {
    id: "step3",
    title: "Step 3: Formalize and Follow-Up",
    scenario: `Mark and Sarah agreed on a plan where 60% of the budget goes to Sarah's channels and 40% to Mark's platform, with clear metrics established for Mark's project. What is the most effective final step to ensure the resolution is lasting and successful?`,
    choices: [
      { id: "A", text: "End the meeting with a handshake and assume the conflict is resolved permanently.", correct:false,
        feedback: "Incorrect. Without formal documentation and follow-up, there's a risk of misinterpretation."},
      { id: "B", text: "Send a follow-up email outlining the agreed-upon action plan, responsibilities, and a future check-in date.", correct:true,
        feedback: "Correct. Documenting the plan and scheduling a follow-up ensures alignment and accountability."},
      { id: "C", text: "Inform their teams about the solution so they can publicly hold Mark and Sarah accountable.", correct:false,
        feedback: "Incorrect. Public accountability can be punitive and damaging."},
      { id: "D", text: "Immediately shift all future budget allocation decisions to the department head to avoid future conflicts.", correct:false,
        feedback: "Incorrect. This removes opportunities to develop conflict resolution skills."}
    ]
  }
];

let current = 0;

function renderStep(idx){
  const step = steps[idx];
  document.getElementById('stepTitle').textContent = step.title;
  document.getElementById('scenarioText').innerHTML = "<p>" + step.scenario + "</p>";
  const choicesDiv = document.getElementById('choices');
  choicesDiv.innerHTML = '';
  step.choices.forEach(c=>{
    const id = 'choice_' + idx + '_' + c.id;
    const label = document.createElement('label');
    label.className = 'choice';
    label.innerHTML = `<input type="radio" name="choice" value="${c.id}" id="${id}"/> <strong>${c.id}.</strong> ${c.text}`;
    choicesDiv.appendChild(label);
  });
  document.getElementById('progress').textContent = 'Question ' + (idx+1) + ' of ' + steps.length;
  document.getElementById('submitAnswer').disabled = true;
  document.getElementById('nextBtn').style.display = 'none';
  document.getElementById('feedbackArea').innerHTML = '';
  // enable submit when a choice selected
  const radios = choicesDiv.querySelectorAll('input[type=radio]');
  radios.forEach(r=>{
    r.addEventListener('change', ()=> document.getElementById('submitAnswer').disabled = false);
  });
  // record an "experienced" statement for the activity step
  const experiencedStmt = makeStatement(
    "http://adlnet.gov/expapi/verbs/experienced",
    "experienced",
    "urn:uuid:marketing-budget-battle:" + step.id,
    {description: { "en-US": step.title }, type: "http://adlnet.gov/expapi/activities/interaction"}
  );
  sendStatement(experiencedStmt);
}

document.getElementById('startBtn').addEventListener('click', async ()=>{
  ensureActor();
  // save config prompt? not needed.
  document.getElementById('intro').style.display = 'none';
  document.getElementById('au').style.display = 'block';
  document.getElementById('status').textContent = 'In progress';
  log('Exercise started by ' + ACTOR.name);
  // initialized statement
  const initStmt = makeStatement("http://adlnet.gov/expapi/verbs/initialized","initialized","urn:uuid:marketing-budget-battle:au");
  await sendStatement(initStmt);
  // fetch an initial prediction and update UI (non-blocking)
  getPrediction().then(res=>console.log('Initial getPrediction result', res)).catch(e=>console.warn('Initial prediction error', e));
  renderStep(0);
});

document.getElementById('submitAnswer').addEventListener('click', async ()=>{
  const radios = document.querySelectorAll('#choices input[type=radio]');
  let chosen = null;
  radios.forEach(r=>{ if(r.checked) chosen = r.value; });
  if(!chosen) return;
  const step = steps[current];
  const choice = step.choices.find(c=>c.id === chosen);
  // show feedback
  const fb = document.getElementById('feedbackArea');
  fb.innerHTML = `<div class="feedback"><strong>Feedback — ${choice.correct ? "Correct" : "Incorrect"}</strong><p>${choice.feedback}</p></div>`;
  document.getElementById('submitAnswer').style.display = 'none';
  document.getElementById('nextBtn').style.display = 'inline-block';
  
  // Console logging for answered event
  console.log('========== ANSWERED EVENT ==========');
  console.log('Step ID:', step.id);
  console.log('Step Title:', step.title);
  console.log('Selected Choice:', chosen);
  console.log('Choice Text:', choice.text);
  console.log('Is Correct:', choice.correct);
  
  // record answered statement
  const ansStmt = makeStatement(
    "http://adlnet.gov/expapi/verbs/answered",
    "answered",
    "urn:uuid:marketing-budget-battle:" + step.id,
    {
      description: {"en-US": step.title},
      interactionType: "choice",
      correctResponsesPattern: [ step.choices.filter(c=>c.correct).map(c=>c.id).join('[,]') ],
      choices: step.choices.map(c=>({id:c.id, description:{'en-US': c.text}}))
    }
  );
  // attach result object
  ansStmt.result = {
    response: chosen,
    success: !!choice.correct,
    completion: false,
    duration: "PT0S"
  };
  
  console.log('xAPI Statement Object:', ansStmt);
  console.log('Actor:', ansStmt.actor);
  console.log('Verb:', ansStmt.verb);
  console.log('Object ID:', ansStmt.object.id);
  console.log('Result:', ansStmt.result);
  console.log('====================================');
  
  await sendStatement(ansStmt);
  log('Answered ' + step.id + ': ' + chosen + ' (success: ' + !!choice.correct + ')');
  // request an updated prediction after answering (non-blocking)
  getPrediction().then(r=>console.log('Post-answer prediction', r)).catch(e=>console.warn('Prediction after answer failed', e));
});

document.getElementById('nextBtn').addEventListener('click', async ()=>{
  current++;
  document.getElementById('submitAnswer').style.display = 'inline-block';
  if(current >= steps.length){
    // completed
    document.getElementById('status').textContent = 'Completed';
    document.getElementById('stepCard').innerHTML = `
      <h2>Exercise Complete</h2>
      <p>Well done — you completed the Conflict Resolution Practice Exercise.</p>
      <h3>Your Mastery Progress</h3>
      <div style="display: flex; flex-direction: column; align-items: center; gap: 20px; margin-top: 20px;">
        <div style="width: 200px; height: 200px; display: block;">
          <percent-gauge id="completionGauge" gauge-band-color="green" gauge-value-decimal="0.0"></percent-gauge>
        </div>
        <div style="text-align: center; font-size: 14px; font-weight: bold;">
          Conflict Resolution Competency
        </div>
        <div style="text-align: center; color: #555; max-width: 400px;">
          This gauge shows your predicted mastery level based on your responses and xAPI learning data.
        </div>
      </div>
    `;
    // Fetch prediction and update gauge
    await getPrediction();
    // completed statement  
    const compStmt = makeStatement("http://adlnet.gov/expapi/verbs/completed","completed","urn:uuid:marketing-budget-battle:au");
    compStmt.result = { completion: true, success: true, duration: "PT0S" };
    await sendStatement(compStmt);
    log('Exercise completed.');
    return;
  }
  renderStep(current);
});

// On page load
window.addEventListener('load', ()=>{
  const arr = JSON.parse(localStorage.getItem('cmi5_local_statements') || '[]');
  if(arr.length) log('Found ' + arr.length + ' locally stored statement(s).');
});
</script>
</body>
</html>
